---
title: "Project Model"
author: "Lynn Fan"
date: "4/26/2020"
output: pdf_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

```{r packages}
library(tidyverse)
library(dplyr)
library(glmnet)
library(car)
library(MASS)
library(data.table)
library(bayesm)
library(ggplot2)
install.packages("R2admb")
install.packages("glmmADMB",
                  repos="http://glmmadmb.r-forge.r-project.org/repos",
                  type="source")
library(R2admb)
library(glmmADMB)
library(lme4)
library(tidyr)
library(mcmc)
library(dplyr)
library(reshape2)
library(bayesplot)
library(varhandle)
library(loo)
```

## Data Cleanup
```{r data cleanup}
data <- read.table("rawdata.txt", 
               col.names=c('stops', 'pop', 'past.arrests', 'precinct', 'eth', 'crime'), 
               fill=FALSE, 
               strip.white=TRUE)
```


## Exploratory Data Analysis
```{r dispersion}
r <- c(mean(data$stops), var(data$stops))
c(mean=r[1], var=r[2], ratio=r[2]/r[1])
```
Overdispersed, so we should do Negative Binomial instead of Poisson.

```{r regression}
stops<-data$stops ; ethi<-as.factor(data$eth) ; precinct<-as.factor(data$precinct);arrest=data$past.arrests
overdisp_fun <- function(model) {
    rdf <- df.residual(model)
    rp <- residuals(model,type="pearson")
    Pearson.chisq <- sum(rp^2)
    prat <- Pearson.chisq/rdf
    pval <- pchisq(Pearson.chisq, df=rdf, lower.tail=FALSE)
    c(chisq=Pearson.chisq,ratio=prat,rdf=rdf,p=pval)
}
# Poisson with random effects
fit.poi <- glmer(stops~1+ethi+(1|precinct),family = poisson(link = "log"), nAGQ = 100)
summary(fit.poi)
overdisp_fun(fit.poi)
# Negative Binomial
fit.nb <- glmer.nb(stops~1+ethi+(1|precinct), verbose=TRUE)
summary(fit.nb)
overdisp_fun(fit.nb)
```

```{r hierarchial}
n <- nrow(data)
precinct.number <- unique(data$precinct)
n.precinct <- length(precinct.number)
precincts <- rep(NA,n)p
pblack <- rep(NA,n.precinct)
for (i in 1:n.precinct) {
  temp <- data[data$precinct==i,]
  blackpop <- temp[temp$eth==1,]$pop[1]
  totalpop <- temp[temp$eth==1,]$pop[1]+temp[temp$eth==2,]$pop[1]+temp[temp$eth==3,]$pop[1]
  pblack[i]<-blackpop/totalpop
}
precinct.category <- ifelse (pblack < .1, 1, ifelse (pblack < .4, 2, 3))
arrests <- data$past.arrests
dcjs <- log(arrests*15/12)
dcjs[which(!is.finite(dcjs))] <- 0
crime <- data$crime
pop <- data$pop
stop_df <- as.data.frame (cbind(stops, ethi, precinct, crime, precinct.category, arrests, dcjs))
stop_df$ethi <- as.factor(ethi)
# Multilevel analysis of NYC police stops

# lmer() fits
M1 <- as.list (rep (NA, 12))
M2 <- as.list (rep (NA, 12))
index <- 0
for (j in 1:3){
  for (k in 1:4){
    index <- index + 1
    ok <- precinct.category==j & crime==k
    M1[[index]] <- glmer(stops~1+dcjs+ethi+(1|precinct), #Poisson with random effect
     family=poisson(link="log"), subset=ok, data=stop_df)
    #Negative Binomial
    M2[[index]] <- glmer.nb(stops~1+dcjs+ethi+(1|precinct), verbose=TRUE,subset=ok,data=stop_df,nAGQ=0)
  }
}
M1[1]
M2[1]
anova(M1[[2]],M2[[2]])
```
negative binomial with overdispersion effect 

how do we know proposal distribution? MVN
Poisson GLM with random effects
If NB: link function for negative binomial, try a bayesian glm package, see the parametization, and change the link
  for negative binomial, the r parameter:
  you need to sample both from beta and r for posterior sampling
  
prior for beta: MVN or whatever in the package
prior for r: uninformative uniform distribution

```{r stop-cleanup}
stop_clean <- as.data.frame(cbind(stop_df$stops,stop_df$precinct.category,stop_df$crime,stop_df$dcjs,stop_df$arrests,to.dummy(stop_df$ethi, "ethi")))
colnames(stop_clean) <- c("stops","precinct.category","crime","dcjs","arrests","black","hispanic","white")
``` 

```{r bayesm-1}
R=1000
set.seed(66)
simnegbin = function(X, beta, alpha) {
  # Simulate from the Negative Binomial Regression
  lambda = exp(X%*%beta)
  y = NULL
  for (j in 1:length(lambda)) { y = c(y, rnbinom(1, mu=lambda[j], size=alpha)) }
  return(y)
}
data1<-stop_clean[precinct.category==1 & crime==1,]
nobs = nrow(data1)
nvar = 3 # Number of X variables
alpha = 5
Vbeta = diag(nvar)*0.01
# Construct the regdata (containing X)
simnegbindata = data1
beta = c(-1.1052,1.0529, -0.2125,-0.7315) #what we get from negative binomial regression
X<-cbind(rep(1,length(data1$stops)),data1$dcjs,data1$hispanic,data1$white)
simnegbindata = list(y=simnegbin(X,beta,alpha), X=X, beta=beta)
Data1 = simnegbindata
Mcmc1 = list(R=R)
out = rnegbinRw(Data=Data1, Mcmc=list(R=R))
cat("Summary of alpha/beta draw", fill=TRUE)
summary(out$alphadraw, tvalues=alpha)
summary(out$betadraw, tvalues=beta)
## plotting examples
if(0){plot(out$betadraw)}
```

```{r predictive check}
betadraws <- out$betadraw #posterior beta
alphadraws <- out$alphadraw #posterior alpha
z.mcmc <- NULL
# posterior predictive
for(i in 1:nrow(betadraws)){ 
  z <- simnegbin(X,betadraws[i,],alphadraws[i]) #sampling from the posterior
  z.mcmc <- rbind(z.mcmc, z)
}
ppc_dens_overlay(data1$stops, z.mcmc[940:1000,]) 
```

```{r predictive check}
betadraws <- out$betadraw
alphadraws <- out$alphadraw
z.mcmc <- NULL
# posterior predictive
for(i in 1:nrow(betadraws)){ 
  z <- simnegbin(X,betadraws[i,],alphadraws[i])
  z.mcmc <- rbind(z.mcmc, z)
}
ppc_dens_overlay(data1$stops, z.mcmc[940:1000,]) 
```

```{r bayesian-2}
data2<-stop_clean[precinct.category==2 & crime==1,]
nobs = nrow(data2)
# Construct the regdata (containing X)
simnegbindata2 = data2
beta2 = c(-0.2951,0.9412,-0.3686,-1.0353)
X2<-cbind(rep(1,length(data2$stops)),data2$dcjs,data2$hispanic,data2$white)
simnegbindata2 = list(y=simnegbin(X2,beta2,alpha), X=X2, beta=beta2)
Data2 = simnegbindata2
Mcmc2 = list(R=R)
out2 = rnegbinRw(Data=Data2, Mcmc=list(R=R))
cat("Summary of alpha/beta draw", fill=TRUE)
summary(out2$alphadraw, tvalues=alpha)
summary(out2$betadraw, tvalues=beta2)

betadraws2 <- out$betadraw
alphadraws2 <- out$alphadraw
z.mcmc2 <- NULL
# posterior predictive
for(i in 1:nrow(betadraws2)){ 
  z <- simnegbin(X2,betadraws2[i,],alphadraws2[i])
  z.mcmc2 <- rbind(z.mcmc2, z)
}
ppc_dens_overlay(data2$stops, z.mcmc2[940:1000,]) 
```

```{r bayesian-3}
data3<-stop_clean[precinct.category==3 & crime==1,]
nobs = nrow(data3)
# Construct the regdata (containing X)
simnegbindata3 = data3
beta3 <- c(0.3637,0.8602,-0.5615,-1.0791)
X3<-cbind(rep(1,length(data3$stops)),data3$dcjs,data3$hispanic,data3$white)
simnegbindata3 = list(y=simnegbin(X3,beta3,alpha), X=X3, beta=beta3)
Data3 = simnegbindata3
Mcmc3 = list(R=R)
out3 = rnegbinRw(Data=Data3, Mcmc=list(R=R))
cat("Summary of alpha/beta draw", fill=TRUE)
summary(out3$alphadraw, tvalues=alpha)
summary(out3$betadraw, tvalues=beta3)

betadraws3 <- out3$betadraw
alphadraws3 <- out3$alphadraw
z.mcmc3 <- NULL
# posterior predictive
for(i in 1:nrow(betadraws3)){ 
  z <- simnegbin(X3,betadraws3[i,],alphadraws3[i])
  z.mcmc3 <- rbind(z.mcmc3, z)
}
ppc_dens_overlay(data3$stops, z.mcmc3[940:1000,]) 
```

### References:
https://bbolker.github.io/mixedmodels-misc/glmmFAQ.html#fitting-models-with-overdispersion
https://sakai.duke.edu/access/content/group/cd23a148-0b53-4d1c-9d1e-c66c74e59129/Lectures/songbird.R
http://probability.ca/jeff/ftpdir/adaptex.pdf
http://www2.geog.ucl.ac.uk/~mdisney/teaching/GEOGG121/sivia_skilling/mterop_hastings.pdf

```{r songbird}
# Useful variables
y<-stops ; X<-cbind(rep(1,length(y)),dcjs,ethi)
yX<-cbind(y,X)
colnames(yX)<-c("stops","intercept","dcjs","ethi") 
n<-length(y) ; p<-dim(X)[2]
# Prior parameters
pmn.beta<-rep(0,p) # prior mean for beta
psd.beta<-rep(10,p) # prior sd for beta
# Metropolis settings
var.prop<- var(log(y+1/2))*solve( t(X)%*%X ) #variance for proposal distribution for beta
beta<-rep(0,p) #initial beta
r<-runif(1,0,1)#initial r
S<-10000 # no. of MCMC samples
BETA<-matrix(0,nrow=S,ncol=p) #container
R<-rep(0,S)
ac<-0 # no. of accepts in MCMc
set.seed(1)

## rmvnorm function for proposals
rmvnorm<-function(n,mu,Sigma)
{ # samples from the multivariate normal distribution
  E<-matrix(rnorm(n*length(mu)),n,length(mu))
  t(  t(E%*%chol(Sigma)) +c(mu))
}
## MCMC
for(s in 1:S) {
  
  #proposal: sample a candidate beta
  beta.p<- t(rmvnorm(1, beta, var.prop))
  r.p<- rexp(1,1)
  #evaluate: compute log-acceptance-ratio, then accept/reject
  logr <- sum(dnorm(beta.p,pmn.beta,psd.beta,log=T)) - sum(dnorm(beta,pmn.beta,psd.beta,log=T)) +
    dexp(r.p, 1) - dexp(r,1)
  if( log(runif(1))< logr ) { beta<-beta.p ; r<-r.p;ac<-ac+1 }
  
  BETA[s,]<-beta #store sample
  R[s]<-r
}
cat(ac/S,"\n") #acceptance rate of MCMC
library(coda)
apply(BETA,2,effectiveSize) #ESS
apply(R,1,effectiveSize)
```

